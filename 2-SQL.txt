=================================================================
		  Databases and Postgre SQL
=================================================================
>>>>>>>>>>>>>  Revature Week 2 Training Notes  <<<<<<<<<<<<<<<<<<

Table of Contents:
* Relational Databases
* SQL - Structured Query Language
* Sublanguages
* DDL
* DML
* DQL
* Scalar vs Aggregate
* Nested Query (AKA Subquery or Inner Query)
	* Inline View
	* Select/Fields Inner Query
* Joins
* Roles
* Connecting With Java
* Sequences
* Composite Primary Keys
* Table Inheritance
* Unions
* Opimization
* Noralization
* Procedural Language
* Conceptual Questions
==>Vocab/acronyms
AWS -	Amazon Web Services.
RDS - 	Relational Datatase Service (RDS is Amazon's SPECIFC ser-
	vice; it hosts Relational Databases (RDs).
RDMS - Relational Database Managing System understands SQL and
	puts the data into the database. Has CRUD functionality,
	normalizes, and ACID concepts
Relational Database (RDs) - Uses relational model for data in 
	which tuples (sequences) are stored (in practice, tables)
CRUD - Create Read Update Delete
ACID - Atomicity, Consistency, Isolation, Durability. Acronym rep-
	resenting transactions in a database. 
Security Group - holds rules to filter traffic to/from virtual 
	server.
DDL : Data Definition Language
	CREATE, ALTER, DROP, TRUNCATE
DML : Data Manipulation Language
	INSERT, UPDATE, DELETE, (SELECT)
DQL : Data Query Language
	SELECT
DCL : Data Control Language
	GRANT, REVOKE
TCL : Transaction Control Language
	BEGIN TRANSACTION, COMMIT, SET TRANSACTION LEVEL

Constraints : Part of CREATE table, provides rules for limiting
	 data beyond data type 
	UNIQUE, NOT NULL, CHECK condition, PRIMARY KEY,
	FOREIGN KEY (REFERENCES), EXCLUDE

=================================================================
================== * Relational Databases =======================
=================================================================
DB tools we use remind me of Java's structure: JDK has tools and
houses the JRE which has other files and uses the JVM.
Similarly: AWS contains RDS which uses RDMS that takes user's SQL
and de-codes it to store data in the database(DB)
 ________________	 ________________
| AWS		 | 	| RDMS           |
| ______________ |	| ..... -Tools   |
|| RDS 		||----->| :SQL: -Inteface| 
||-Database	|<------| :...: 	 |
||-S.G.		||	|________________|
||______________||		
|       	 |
/ +++more tools  /

AWS is the Amazon Web service. Secure cloud services platform with
   server, database & computing-related tools. Essentially, AWS 
   tools are for developers to create and launch applications 
   without their own hardware/servers. The physical servers are 
   off somewhere else remotely. 
RDS -Amazon Relational Database Services - AWS's Relational data-
   base service. From here, databases can be created and data
   is actually stored. The RDS has security group capability which
   restricts access to only permitted users.
	*** The DB is located here
S.G. - Security Group
RDMS - 	Relational Database Managing System - program that enables
   permitted users to interact with a relational database. Most 
   commonly, RDMSs use SQL. Basic CRUD funcionality. Uses normal-
   ization, primary/foreign keys,integrity checks, and ACID 
   properties. Security groups provide security at protocol/port
   access level. They work like a firewall and contains rules that
   filter traffic to/from virtual server.
	-- RDMS (Also called RDBMS) examples 
		- Oracle
		- PostgreSQL
		- MySQL
		- SQLite
	- DBMS (Database Management Systems) not specific to RDBs
	  are about to house multiple different types of database
	  management systems.
SQL - Structured Query Language (More in next section)
Relational Database - data is represented with tuples - a finite 
   order list(sequence) of elements - in which users state what 
   information the database contains and what information they 
   want to see, letting the database deal with the data structure
   for storing data and retrieving procedure.
	>> Relational Database describes tables and holds data in
	a way that data can be accessed without reorganizing the 
	entire database table.

==> Relational Databases Relation to Java
        ___RDs___             _____Java_____
	- Columns	- Fields/Instance variables
	- Rows		- Object/ Instance of a class
	- Tables	- Collection

==> ERD : Entity-Relationship Diagram
[Source : https://www.techopedia.com/definition/1200 ]
- Modeling technique that graphically illustrates DB relationships

1. Entities - Database Tables
2. Relationships - Foreign keys references
3. Attributes - Columns

==> What does "relational" really mean?
- Relational refers to how we label data in the columns.
- Say we have this table:
	 _________________________
	|_Name_|_Age_|_Hair Color_|
	| Tom  | 24  |  brown     |
	| Sandy| 55  |  black     |
	|Brooke| 21  |  blonde    |
	 -------------------------
 It represents the data's relationship to other sections. 
The columns represent an attribute and teh rows represnt a 
instance. So we can say "In this database, what are the names"
and get "Tom, Sandy, Brook" because the relationship between
Tom, Sandy, and Brook is that they are all names.
We can also say "In this table where name = Tom, what are the
related attributes?" and get back another table:
	|_Name_|_Age_|_Hair Color_|
	| Tom  | 24  |  brown     |
Because 24 and Brown are related to the row where name = Tom.

==> Why do we need to specify we are using Relational Databases?
[Source : https://computer.howstuffworks.com/question599.htm ]
--- Prior to the development and popularity of RDs, data was
 typically stored in the form of one long text file with entries
 divided by a specfic character. For example:

Lname, FName, Age, Salary|Smith, John, 35, $280|Doe, Jane, 28, 
$325|Brown, Scott, 41, $265|Howard, Shemp, 48, $359|Taylor, Tom,
22, $250

---Data stored in a long file can be read and accessed, but 
it is difficult to reorder the information. You need to search
through the entire sequence in order to get one piece of infor-
mation.  
--- With Relational Databases, you can easily find specific infor-
mation because it allow you to bort based on any field and gener-
ate a report that contains only certain fields.


=================================================================
============ * SQL - Structured Query Language ==================
=================================================================

- SQL is a language used to communicate with a database.
- ANSI(American National Standards Institute)manages its standards

==> Relational Database System
Tables are made up of rows (x) and columns (y).
Rows : represents instances (object)
Columns : represents variables (field)

- Tables should have an index column/ID Column 
	-Something unique for each element
- When tables are created, a data type must be specified.
- The ID column is called a Primary Key.
- Primary Key is unique idenifier for any given rom.
- Typically numeric.

==> COMMON TYPES: 
character-related
	CHAR - will append whitespace generally
	VARCHAR - won't append. Varying # of characters(String)
	TEXT - arbitraty size.
Integer
	INTEGER (in java, int)
	BIGINT (in java, long)
	SMALLINT (in java, short)
boolean
date
numeric <- Variable precision
+ and many more

==> PostgreSQL  
- An object-relational RDBMS which extends SQL
- This document includes some PostgreSQL-specific operations 
- PostgreSQL is liscenced by PostgreSQL Global  Development Group.

- WHY?
	- Object-relational DBMS
		-tables support classes/inheritance
	- ACID-compliant and transactional.
	- Reliable
	- Many 3rd party tools
	- Can programmatically store procedures
- Disadvantage :
	- Not as popular as MySQL (more difficult to host)
	- Not the fastest 

==> What is a database?
	Database stores data. See first section.
- DB is not part of java application. 
- To get started, add a Maven Dependency to your Java project:

API to comminicate between java and DB:
	Java 2DB (to database)  API -> JDBC

==> General standards for SQL:
	- SQL keywords are written in CAPITAL letters
	- non-SQL letters(user-created) are written in lowercase
	- Multi-word names written using underscores_to_seperate

=================================================================
			* Sublanguages
=================================================================
SQL is broken into a number of sublanguages. 
- Sublanguages are groupings of commangs on related operations.
- Consider thinking about it in steps.
	Step 1. Define data structures
	Step 2. Manipulate Data
	Step 3. Using Querys, select the data
	Step 4. Control who gets to use the data
Main lanuages:
DDL : Data Definition Language
	CREATE, ALTER, DROP, TRUNCATE
DML : Data Manipulation Language
	INSERT, UPDATE, DELETE, (SELECT)
DQL : Data Query Language
	SELECT

Other Important Languages (Defined later on)
DCL : Data Control Language
	GRANT, REVOKE
TCL : Transaction Control Language
	BEGIN TRANSACTION, COMMIT, SET TRANSACTION LEVEL

=================================================================
		* DDL - Data Definition Language.
=================================================================
- DDL is dedicated to creating, altering, & removing db objects
	(DB objects are primarily tables.)

- Key operations as part of DDL are:
1. CREATE - create an object (table)
2. ALTER - alter an object (an existing table)
3. DROP - Remove/delete a table
4. TRUNCATE - remove data from table, but leave table structure.

Create a user table:
Syntax:__________________________________(-- creates comment)
CREATE TABLE users (
	-- column definitions
	-- column_name COLUMN_TYPE OTHER_SPECIFICATIONS
	id INTEGER PRIMARY KEY,
	first_name VARCHAR(20),
	last_name VARCHAR(20),
	phone VARCHAR(10),
	email VARCHAR(50)
)
__________________________________________
-- Can use:
	CREATE TABLE IF NOT EXISTS users 
 if you plan to run the same script multiple times.


-SERIAL psuedotype 
	- If you set a column to type serial on creation, it will 
 be converted into an integer column, generate a Sequence, and
 use that sequence as a default value.
	- Functionally, setting column to serial results in us 
 getting default sequential numbers.
 	- if you have a SERIAL ID, it Allows you to insert data 
 into the table without specifying an ID by automatically 
 generating one


-- CONSTRAINTS provide rule(s) for limiting valid data beyond type
1. UNIQUE - a unique colunm specifies that all rows must have 
	 - all unique values in this column.
2. NOT NULL - at least one not null column is required
	 - no null values are accepted.
3. CHECK - accepts an expression that row data must pass.
4. PRIMARY KEY - unique identifying column for any given row. 
	- Implicitly UNIQUE and NOT NULL
5. FOREIGN KEY(REFERENCES) - points to another column 
	- must hold a valid reference to that column.
6. EXCLUDE - Allows you to check a given comparison operator
	and fails if all comparisons return true

Foreign key:
Combine keywords to create a 2nd table which references the 1st
-- Table structure for a post by some user (user table above)
CREATE TABLE IF NOT EXISTS posts (
	id INTEGER PRIMARY KEY,
	author_id INTEGER REFERENCES users(id) NOT NULL
	content VARCHAR(500) NOT NULL
)

-- IF NOT EXISTS function only creates the table IF a table by
	--that name doesn't exist.
-- DROP removes tables completely.	
	DROP TABLE posts;
	DROP TABLE users;

-- ALTER table modifies existing tables.
   -- Add column: 
	ALTER TABLE users
		ADD COLUMN test INTEGER;
   -- Change datatype of column
	ALTER TABLE users
		ALTER COLUMN test SET DATA TYPE VARCHAR(2);
   -- Add constraint to column
	ALTER TABLE users
		ALTER COLUMN test SET NOT NULL;
   -- Remove a column
	ALTER TABLE users
		DROP COLUMN test;


==> Review: 
DDL operations:
	CREATE
	ALTER
	DROP
	TRUNCATE
CONSTRAINTS:
	PRIMARY KEY
	NOT NULL
	REFERENCES
	UNIQUE
	CHECK
	EXCLUDE
	
=================================================================
		* DML - Data manipulation Language
=================================================================
DML - Data manipulation language,
1. INSERT - Allows us to enter new data. (row)
2. UPDATE - allows us to update existing table data (row)
3. DELETE - allows us to gelete table data (row)
4. SELECT - allows us to view table data (is also often considered part of a different sublanguage)


-- INSERT anatomy
  INSERT INTO table_name (col_1, col_2, ...) VALUES 
	(data_1, data_2, ...);

---- EXAMPLE: 
  INSERT INTO users (id, first_name, last_name, phone, email) VALUES
	(1, 'Abby', 'Addams', '1234567890', 'email@amail.com');



-- DELETE 
	-- Delete clause will delete the specified information
	-- Does NOT delete table structure, just the info inside
  DELETE FROM users; -- Will delete all of the data on users.

==> WHERE
	--WHERE is a control-flow clause used to filter results
	--Use after defining a table. 
  DELETE FROM users WHERE id = 2;

-- IN operation specifies multiple values in WHERE clause
	-- Works like "OR"
	-- Example from https://www.w3schools.com/sql/sql_in.asp
  --Table Customers has information on Country
  SELECT * FROM Customers
  WHERE Country IN ('Germany', 'France', 'UK');
	-- Can be combined with SELECT statement
  SELECT * FROM Customers
  WHERE Country IN (SELECT Country FROM Suppliers);

-- BETWEEN operator selects values within a range 
  SELECT * FROM Products
  WHERE Price BETWEEN 10 AND 20;
	-- Can also be used with text values to select alphabetically

-- Checking for NULL
	-- Null is nto a value, so use IS or IS NOT instead of =
  SELECT * FROM Products
  WHERE Price IS NOT NULL;


** CAREFUL because the tool auto-commits.
	You can change it, but overall just don't mess up.
UPDATE allows you to change things.
	ROLLBACK is OK
UPDATE 'column_name'  = 'newName' WHERE id = 4;


===============================================================
		*DQL - Data Query Language	
===============================================================

-- DQL ONLY has SELECT. 
SELECT  - tool for retrieving data from out database.
	- Some consider SELECT to be DQL, others consider it DML

==> BASIC ANATOMY
  SELECT col_1, col_2, ... FROM TABLE table_name;
Example:_________________________________________
  SELECT id, first_name, last_name, FROM users;
 _________________________________________________

==> Wildcards
-- * is a wild card/ gives all possible  vals
	- CAN ALSO USE SOME BASIC EXPRESSIONS / CONCATENTATION.
  CONCATENATION : first_name || 'Abby'   
	will add "Abby" to all first_name vals selected.

-- LIKE works with the % wildcard.
	- % is a substitution for zero or more characters
	-- LIKE keyword translates roughlt to "containing"
  SELECT * FROM users WHERE email LIKE '%ag.com';
	--will select only emails that end with 'ag.com'

	-- FIND A LETTER in a name
  SELECT * FROM users WHERE LOWER(last_name) LIKE '%c%';

--_ Underscores: find letters done a certain way:
 ____y (4 underscores and a y) 
	-- will look for a username 5 chracaters long ending in y.

--[charlist] Wildcard
	-Operates like "or" betwen each letter
	- Example, from cities table, get name starting with [b or c or d]
 SELECT * FROM cities
 WHERE name LIKE '[bcd]%';
--[!charlist] or [^charlist]
	-- matches only characters NOT specified within brackets


==> LOWER(column_whatever) converts the column into all lowercase.

  SELECT * FROM users where LOWER 


==> Can use boolean writing:
  SELECT * FROM user WHERE id > 1
  SELECT * FROM user WHERE id < 1

==> Provide a set to get a number of sections:
- Utilizes information in the form of specific numbers.
  SELECT * FROM users WHERE id IN (1, 2, 4);

==> use BETWEEN x AND y for ranges:
  SELECT * FROM user WHERE id BETWEEN 1 AND 4;'

==> Combine queries :
SELECT * FROM user WHERE (id BETWEEN 1 AND 4) AND last_name = '%a%;

SELECT * FROM user WHERE (id BETWEEN 1 AND 4) OR last_name = '%a%;

==========================================================================
		* DML - Data manipulation Language
==========================================================================

DML - Data manipulation Language
1. INSERT
2. UPDATE
3. DELETE
4. SELECT ( Some say this is DQL, though)

INSERT INTO posts()


==========================================================================
			* Scalar vs Aggregate
==========================================================================

==> Scalar functions return single values, as opposed to sets of values.
	- SQL scalar, for example, may return a username associated with
	  a specific user ID
	- DEFAULT EXAMPLES:
	
    UCASE()
    LCASE()
    MID()
    LEN()
    ROUND()
    NOW()
    FORMAT()

		- CURRENT_TIMESTAMP
		- Numberic functions * / + -
		- Concatentation
			string_value || string_value
		= Substring 
			SUBSTRING(starting_string FROM start_letter)
			SUBSTRING(starting_str FROM start_ltr FOR end_ltr)

==> Agregate functions - aggregate: to put things together.
	- Aggregate functions return tables or multiple values.
	- DEFAULE EXAMPLES:
		
    AVG()
    COUNT()
    FIRST()
    LAST()
    MAX()
    MIN()
    SUM()


==Aggregate COUNT function
	-- Counts ALL rows in posts table and returns one bigint number.
  SELECT COUNT(*) FROM posts;
 
-- Gets author ID, 
	& counts ALL from posts grouped by (with the same) author_id 
  SELECT author_id, COUNT(*) FROM posts GROUP BY author_id;

-- WHERE [FILTER] filters PRIOR to aggregation

  SELECT author_id, count(*)
	FROM posts
	WHERE author_id < 2
	GROUP BY author_id;

-- To filter POST (after) aggregation, we should use a HAVING clause a
  SELECT author_id, count(*)
	FROM posts
	GROUP BY author_id
	HAVING count(*) > 20;
	-- Counts posts, showing authors having more than 20 posts

SELECT user_id, sum(*)
	FROM key_table
	WHERE username = 'someuser2'
	(??? how to add the values together?)

SELECT author_id, MAX(id)      < --- Can get MAX, MIN
	FROM posts;

-- AVG(column) will get the AVERAGE of all the selected values.
IE Get the average of all user's posts:
SELECT author_id, AVG(id)
	FROM posts
	GROUP BY author_id  

Other functions : FLOOR(___) CEIL(___)

ORDER BY COUNT(CustomerID) DESC
ORDER BY COUNT(CustomerID) ASC

LIMIT clause 
-sets the upper limit on the number of tuples (rows) returned
==========================================================================
				* Nested Query
==========================================================================
- Nested query also called Subquery or Inner query
- A way of putting a query inside a query.
- Principally, using the result of a query as part of another query.

CONSIDER: How to get all posts by abby HOWEVER we don't know abby's ID,
	  just her first name - 'Abby'

TIP : Work from the inside out.
SELECT * FROM POSTS WHERE author_id = 
	(SELECT id FROM users WHERE LOWER(first_name) LIKE 'billy')

==> Guidelines: 
https://www.w3resource.com/sql/subqueries/understanding-sql-subqueries.php
- Subquery must be enclosed in parenthesis.
- Must be placed on the right side of the comparicon operator(of any)
- Cannot maniuplate results interally; ORDER BY clause cannot be added.
- Use single-row operators with single-row subqueries
- If subquery/inner query returns null value to outer, the outer will
   not return any rows when using certain comparison operators in WHERE
==> TYPES of SubQueries
- Single Row Subquery : Return zero or one row
- Multiple row 
- Multiple Column
- Correlated Subquery - references one of more columns in the outer SQL
		 	statement. 
		      - Called correlated because it relates to outer table
- Nested Subquery : Subquery placed inside another subquery

==> Allowed statements in Subqueries
- INSERT


--------------------------------------------------------------------------
* INLINE VIEW 
--------------------------------------------------------------------------
- A VIEW is a virtual table - it is a tables presented when selecting
  particular data from the database table, but does not acutally hold any
  data of it's own. It references sections of the real table.
- Inline view is a SELECT statement in a FROM clause.

  SELECT content FROM
	(SELECT * FROM posts WHERE id < 50) inner_table
  WHERE id > 30;

-- inner_table is an "alias" that can be used to get that same table again later on.

--------------------------------------------------------------------------
* SELECT/FIELDS INNER QUERY
--------------------------------------------------------------------------

 SELECT * FROM users;

 SELECT count(*) FROM posts GROUP BY author_id;
 SELECT count(*) FROM posts WHERE author_id = 1;

   |
   |    Instead of "FROM," a comma calls that value AS total_posts
   |   FROM the users
   V

 SELECT *, 
  (SELECT count(*) FROM posts WHERE author_id = users.id) AS total_posts 
 FROM users;

-Note total_posts is an alias used to make the code more readable.
 it is the name given to the column of the results.

== > SCRIPT ANALYSIS:
- First query runs on users, getting all data realted to users.
The ID field on the users table is then used to provide the filter on the 
inner query. This results is each row having the count of only the current 
row's user's posts.

SCALAR FUNCTION CS AGGREGATE FUNCTION
-- Aggregate fnctions accept sets of data and operate by utilizing the function on the entire set.
Ex: AVG finds the average of a set of data.

-- Scalar functions operate on a singlar data-points. Scalar funtions will not condence a result set, but will return a single values. FLOOR, CEIL, ROUND, UPPER, LOWER.

-- Scalar functions Has no affect on the result set itself, only individual column values
SELECT UPPER(first_name) FROM USERS;

-- Aggregate function - condenses results to a single row or rows for each factor in a 'group by' clause
SELECT AVG(id) FROM users;

SELECT author_id, MIN(id) FROM posts GROUP BY author_id;

==========================================================================
		* Joins
==========================================================================
Joins allows to combine results from multiple tables horizontally. 
 When joining we join ON some expression, which provides how rows from one
table are related to another table. Generally, this will be a foreign key.

-- Example use: Many-to-many relationship:

  CREATE TABLE friends (
	id SERIAL PRIMARY KEY,
	requester INTEGER REFERENCES users(id) NOT NULL,
	reciever INTEGER REFERENCES users(id) NOT NULL
  );

  INSERT INTO users (first_name, last_name, phone, email) VALUES
	('Danny', 'Deloto', '1231231234', 'danny@dogpile.com'),
	('Emily','Erikson', '1233465234','emily@dsaf.xom');

  SELECT * FROM users;

  INSERT INTO friends (requester,receiver) VALUES
	(1,3), --Abby is friends with Billy
	(3,4),
	(1,4),
	(4,6);
	
  SELECT * FROM users WHERE id = 1;

-- Show user's 10 newest posts:
-- Joins to put information from the 2 tables together :
  SELECT reciever,users.first_name, users.last_name, posts.*
  	FROM friends
	LEFT JOIN users ON reciever = users.id
	LEFT JOIN posts ON reciever = posts.author_id
	WHERE requester = 1
	ORDER BY posts.id DESC --descending, ACS > ascending
	LIMIT 10; --newest 10 only

-- Or show ALL FRIENDS
 SELECT * FROM friends;
 SELECT friends.requester, request_users.first_name, reciever_users.first_name, friends.reciever
	FROM friends
	LEFT JOIN users AS request_users ON requester = request_users.id
	LEFT JOIN users AS reciever_users ON receiver = receiver_users.id;

==>Referential Integrity
- All relationships between tables should be described by foreign keys.
- When you violate referential integrity, we're left with "orphan rows" 
  or "orphan references!"
- Bad idea to violate referential integrity
- Ideally, only join tables that have referencing rows.

==> Types of Joins:
- INNER JOIN - Selects only overlapping row (matches both)
		
- FULL OUTER JOIN - Selects only records unique to each table
- LEFT OUTER JOIN - Selects all, matches equal, if no match, right null.
		    use WHERE TableB.is IS NULL to get only unique 
		    records in A
- CROSS JOIN	Joins each element in A with each element in B
		Multiplies size. 
     IE: Table1.Letters [a, b, c] Table2.Numbers[1,2,3]
	SELECT Table1.Letters, Table2.Numbers
	FROM Table1
	CROSS JOIN Table 2
		--Results:
		a 1
		a 2
		a 3
		b 1
		b 2
		b 3
		c 1
		c 2
		c 3
- LEFT JOIN just tacks on the other tables, typically at reference 
- SELF-JOIN - regular join, but the table joins with itself.
	Example: You have a table with people and cities.
		You can use self-join to create a new table that pairs up
		people by what city they are in.

==========================================================================
				* Roles
==========================================================================

-Roles are a way for us to provide new credentials for other users, either
 people or applications.
- When defining a role, we first specify a login and password, and then can
 grant or revoke various privileges. This allows us to limit the use of a
 database to exactly the tasks the user requires
--- IE Can limit roles to specific actions (view, delete, add, ect.)


CREATE ROLE jdbc WITH LOGIN PASSWORD 'passw0rd' VALID UNTIL '2018-12-12'
-- VALID UNTIL 'yyyy-mm-dd' lets password ect expire, not mandatory

--If you want to test this, you can add a new server to you DB as new user
>> Use the same endpoint as your DB (copy from properties)
>> add a name
>> username : jdbc
>> password : p4ssw0rd
^^ Above is so we can do testing. We will use something similar in java 
so that we have our specific password ect like this instead of putting 
passwords to the entire database in our java program.

--Allow jdbc role to use the SELECT operation on the users table.
GRANT SELECT ON users TO jdbc;

For all:
GRANT ALL PRIVILEGES ON users TO jdbc;
or:
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO jdbc;
still might not be able to insert since insert works on the schema.
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO jdbc;

REVOKE SELECT ON users FROM jdbc;

remove user:
DROP ROLE jdbc;

-- Provide default privileges which will apply to even new database object:
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ON ALL TABLES TO jdbc;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO jdc;
-- ^^ Automatically is applied to new db objects created by jdbc
-- IF default privileges not aplied to jdbc, they could create a new table
-- and then not be able to access it at all.


CORRECTED FOR ERRORS:
--CREATE ROLE jdbc WITH LOGIN PASSWORD 'p4ssw0rd' VALID UNTIL '2018-12-12';

GRANT ALL PRIVILEGES ON users TO jdbc;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO jdbc;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO jdbc;

-- Provide default privileges which will apply to even new database object:
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO jdbc;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO jdbc;
-- ^^ Automatically is applied to new db objects created by jdbc
-- IF default privileges not aplied to jdbc, they could create a new table
-- and then not be able to access it at all.

==========================================================================
			* Connecting with Java
==========================================================================

********************* IN JAVA **********************
Connecting to a DB via DriverManager, more likely to 
get SQLException, esp if connection fails
*****************************************************

Java util package.  ConnectionUtil class:
_________________________________________________
public class ConnectionUtil {
	
	public static Connection getConnection() {
		try {
			// FROM https://jdbc.postgresql.org/documentation/80/connect.html
			// jdbc:postgresql://host:port/database
			// Username(which is jdbc) : database name :// endpoint : port : 
			String url = "jdbc:postgresql://ENDPOINT:5432/postgres";
			return DriverManager.getConnection("a","jdbc","p4ssw0rd");
		} catch (SQLException e) {
			return null;
		}
	}          
}
_________________________________________________


-- Using the Statement class with user provided data opens yourself up to
   SQL Injection attacks.
 SQL injection can be devestationg. Fortunately, there're easy to prevent.
 Don't concatanate user data into a SQL query. Use prepared statements and
 the appropriate paramets setting emthods to add data to a query. WHen 
 using prepared statements correctly, SQL injection will be rendered 
 impossible.

==> ALWAYS use the "?" and PreparedStatements

HIDING INFORMATION : 
--Don't put your password blatantly on the source file.
--Files containings source files should be hidden with environment
  variables -- variables stored on one's actual SYSTEM.

System.getenv("jdbc_login");

ON WINDOWS:
Start > Edit environment Variables (in System Properties)
>> New
	>> input variable name and the value is the username
	>> Do the same but for password.
in Java:
System.getenv("JDBC_LOGIN");
System.getenv("JDBC_PASSWORD");


==> DAO Database Access Object
Out DAO should be able to handle CRUD functionality for user entity
C - Create   -	INSERT
R - Read     -	SELECT
U - Update   -	UPDATE
D - Delete   -	DELETE

Note : PreparedStatement ps
 ps.executeQuery() returns something vs s.execute() does not

Postgres allows us to use a returning clause to return info on the 
instance we just created in the table.

INSERT INTO users (first_name, last_name, phone, email) VALUES 
	('Frank','Georgeson','1231231234','georg@goerge.net)
	RETURNING id;

==> Instead of making HUGE select statements in your java, its easier to 
	use IDs.

-- VIEWS - views are essentailly a saved and named query that can be used
	   again later.

 -- table gets friends abby has requested at least.
SELECT user_friends.* FROM users
	INNER JOIN friends ON users.id = requester
	LEFT JOIN users AS user_friends ON recIever = user_friends.id
	WHERE requester = 1;
	
Use rather

CREATE VIEW friend_view AS SELECT requester, 
	user_friends.* FROM users
	INNER JOIN friends ON users.id = requester
	LEFT JOIN users AS user_friends ON recIever = user_friends.id;

-- Now use to get all of someone's friends (requester with id 1)
SELECT * FROM friend_view WHERE requester = 1;

-- Altering view: use CREATE OR REPLACE
CREATE OR REPLACE VIEW friend_view AS SELECT requester,
	user_friends.* FROM users
	INNER JOIN friends ON users.id = requester
	LEFT JOIN users AS user_friends ON recIever = user_friends.id;

==========================================================================
			* Sequences
==========================================================================
Sequences provide a way of creating stateful counters within our database.
We can create sequences using standard DDL notation.

CREATE SEQUENCE my_custom_sequence;

SELECT nextval('my_custom_sequence');


- Will keep going down the list.
- Use for bank account numbers: 
CREATE IF NOT EXISTS my_basic_sequence
	increment by -3
	MINVALUE 1000
	MAXVALUE 1010
	START 1000
	CACHE 1 --FOR SAVING VALUES TO USE LATER, SPEED AND STUFF
	CYCLE;

-- Banking account sequence:
CREATE SEQUENCE IF NOT EXISTS
	INCREMENT BY 1
	MINVALUE 1000000;
SELECT nextval('banking_account_sequence')
SELECT nextval('my_basic_sequence');


=========================================================================
			* Composite Primary Keys
=========================================================================

Composite Primary Keys:
-- Composite key that is composed of two or more columns.


  CREATE TABLE IF NOT EXISTS example_composite (	
	val_one INTEGER PRIMARY KEY,
	val_two SERIAL,
	PRIMARY KEY (val_one,val_two)
  );
  INSERT INTO example_composite VALUES (1),(1),(1);
  SELECT * FROM example_composite;
--OR
  INSERT INTO exmaple_composite (val_one, val_two) VALUES (2,1);
-- This is fine, so long as that particular composite value isn't repeated. 


 Can also have composite Unique constraints:
  CREATE TABLE IF NOT EXISTS example_composite (	
	val_one INTEGER PRIMARY KEY,
	val_two SERIAL,
	UNIQUE (val_one, val_two)
  );
-- Unique constraints doesn't consider null values as unique or not. 
-- set NOT NULL to avoid that.




===========================================================================
		* TABLE INHERITENCE: (Posgres specific)
===========================================================================
  CREATE TABLE IF NOT EXISTS birds (
	id SERIAL PRIMARY KEY,
	name VARCHAR(20)
  );

  CREATE TABLE IF NOT EXISTS chickens (
	eggs_laid INTEGER
  ) INHERITS (birds);

  CREATE TABLE IF NOT EXISTS hawk (
	rabbits_eaten INTEGER
  ) INHERITS (birds);


  INSERT INTO chickens (name, eggs_laid) VALUES ('Cluck',200);
  INSERT INTO hawk (name, rabbits_eaten) VALUES ('Claw',20);
  INSERT INTO birds(name) VALUES ('rebirdo');

--SHOWS all 3 rows but no extra columns
 SELECT * FROM birds; --Gets everything considered a type of bird. 
--They all share the same serial sequence. 
--THey're drawn from the same set of IDs. 
--Can select directly from the chickens table and see only chickens 
--(and get the extra row) 
-- only chickens, with chicken extra columns

SELECT * FROM chickens
-- only hawks, with hawk column

SELECT * FROM hawk
--Only things defined on birds, not inheriting tables.
SELECT * FROM ONLY birds


=========================================================================
			        * UNION
=========================================================================
UNION, UNION ALL, INTERSECT, AND MINUS

Joins combine result sets horizonally. 
These operations combine or interact with result sets horizontally.

SELECT id, reciever AS friend_ID FROM friends WHERE requester = 3
UNION -- Combine result set of 2 diff queries.
SELECT id, requester AS friend_id FROM friends WHERE reciever = 3;
-- Note that union adds new rows and does NOT add duplicates.

-- You can use UNION ALL to keep duplicates/repeated columns.
SELECT id, reciever AS friend_ID FROM friends WHERE requester = 3;
UNION -- Combine result set of 2 diff queries.
SELECT id, requester AS friend_id FROM friends WHERE reciever = 3
UNION ALL
SELECT id, requester AS friend_id FROM friends WHERE reciever = 3;

==> EXCEPT / INTERSECT
- This can be done with WHERE clauses, but this is simpler
-- EXCEPT returns distinct values from the query on the left
   that are NOT returned from the right query
Example: This table is friedns with BILLY who are NOT fiends with Abby
	- Basically the opposite of friends in common.
  -------------------------------------------friends of billy
  (SELECT id, reciever AS friend_ID FROM friends WHERE requester = 3;
  UNION -- Combine result set of 2 diff queries.
  SELECT id, requester AS friend_id FROM friends WHERE reciever = 3
  UNION ALL
  SELECT id, requester AS friend_id FROM friends WHERE reciever = 3)
  EXCEPT -----------------------EXCEPT
  ---------------------------------- This shows abbys' friends
  (SELECT id, reciever AS friend_ID FROM friends WHERE requester = 1
  UNION -- Combine result set of 2 diff queries.
  SELECT id, requester AS friend_id FROM friends WHERE reciever = 1)

- Basic Syntax:
View 1
EXCEPT 
View 2

-INTERSECT returns distince values returned by BOTH queries.
  -- Finding MUTUAL FREINDS use INTERSECT to remove results that are 
  -- not present in both data sets
  (SELECT id, reciever AS friend_ID FROM friends WHERE requester = 3;
  UNION -- Combine result set of 2 diff queries.
  SELECT id, requester AS friend_id FROM friends WHERE reciever = 3
  UNION ALL
  SELECT id, requester AS friend_id FROM friends WHERE reciever = 3)
  INTERSECT-------------------------------------------INTERSECT
---------------------------------- This shows abbys' friends
  (SELECT id, reciever AS friend_ID FROM friends WHERE requester = 1
  UNION -- Combine result set of 2 diff queries.
  SELECT id, requester AS friend_id FROM friends WHERE reciever = 1)

==> DISTINCT keyword wil remove duplicate items from the results.
SELECT DISTINCT content FROM POSTS
=========================================================================
			* OPTIMIZATION:
=========================================================================

- Databases can more quickly look things up via primary key. 
  This is because primary keys are indexed, and can go right to it.

- Databases can also define indexes for table elements.
-- IE it makes sense for emails to be indexed so that we can more quickly 
   find them.

  SELECT * FROM USERS;
  CREATE INDEX users_email_index ON users(email);

-- Don't just create indexes everywhere.
-- Updates/inserts/deletes will have more overhead, and we need more space
   allocated. Choose it carefully depending upon HOW the data is used. 
   Example : for logging in with a username.
- Downside : There can only be 1 clustered index per table.

==> Clustering - Clustering allows to restructure data in the database to
    fit the ordering of an index.
- Note : This ordering is not maintained; 
 	 it must be done again occasionally if its necessary, 
	 to maintain this ordering for performance.

  CLUSTER users USING users_email_index;
  SELECT * users;

-- Will now show a list of users with their email addresses in order.


=========================================================================
			* Normalization
=========================================================================
-- The process of removing redundant data from our system. 

-- Process is broken into levels.
Rules of the levels of normal form
-- First normal form (1NF)
    -- 1. Every tables must have a primary key
    -- 2. Every column must be automic
      ---- automic : no column should be able to be broken into smaller 
		     bits of data. IE: Name is not (generally) automic,
		     firstname/lastname columns are.
      ---- IE Addresses should be broken into a lot of parts

-- Second normal form (2NF)
   --1. Must meet restrictions of first normal form
   --2. The non-key columns within a composite key table must be specific
	to both entities which make up the composite relationship.
	---- Must be directly about ALL parts of the key.
	EX: customer_account could have a row called # of transactions
	which is specifically that user's # transactions on that account.

-- Third normal form. (more complex than we're making it)
   --1. Must meet restrictionsof second normal form.
   --2. Columns must not represent transitive functional dependencies
	-- No column data should be able to be derivable from column
	   statement.

==> Functional Dependency:
       		(table about sales) 
	quantity  price_at_time_of_sale  total
	 2                5                10

-Total can be derived from other columns, so it is not necessary. 
	This violates 3NF.


==>Transitive Dependency
	  city 	  state
	  Tampa	    FL
- We should be able to derive a state from a city. These representatios 
  should be borken into multiple tables - IE city and state table, where
  each city holds a reference to its respective state.


Denormalization
-- Adding redundancy back into your database  may imporove performances
   if you've normalized tooo far.


=========================================================================
			* TRANSACTIONS
=========================================================================
- Transactions - the idea of multiple database interactions being combined 
into a single atomic transaction.

- The idea is that many interactions are dependant upon preceeding 
 interactions. And many larger problems or solutions we utilize require 
 multiple edits to the database. Transactions allow us to be sure that 
 all parts of a transaction occur correctly without fail.

-- When a customer orders something a few things should all happen:
1. The order is add to the user's order history.
2. Inventory is an intentory table is updated to respect the new form of
   the inventory.
3. The order is placed in a table for pending fulfulments for picking
   from warehouse.


-- Transactions allow us to place multiple operations together, where
   if one fails they can all fail together.
-- Transaction related changes make up the sublanguage TCL

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ TCL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. BEGIN (among others) - starts a new transaction
2. COMMIT - Commits a transaction, saving all changes)
3. ROLLBACK - Rolls back al changes to a given point.
4. SAVEPOINT - creates a savepoint withing a transactionwhich can be rolled back to
5. RELEASE - releases a savepoint from memory within a transaction. 

 BEGIN  TRANSACTION;
   INSERT INTO users (first_name, last_name, phone, email, city_id) VALUES
   ('Isabely','Ivy','1234567890','isy@imail.com')
 COMMIT;

 ******************************* ACID *****************************
- ACID is a huge concept for SQL databases. 
- Be able to explain it confidently. 

A - Automicity - Transaction that can't be broken down into smaller parts.
	- Either finish wholly or are completely rolled back.
 		- There should be no partial completion of any 
	transaction.
	- In acid this applies to transactions
C - Consistency - (The rules of the database)
	- Transactions take us from one consistent state to another 
	 consistent state. Rules should still be consistent before, after,
	 and throughout the transaction.
I - Isolated - Transactions occur as if they are occuring in a vacuum. 
	If multiple concurrent transactions occur on the database at one 
	time, the changes of these interactionsshould not interact.
D - Durable - Once a transaction is committed, There is no going back.
	After completion, the changes are the new state of the application.
	IF you are a DBA: is also means that out database should maintain 
	transactions even in the case of disaster.

===> Transaction Isolation Levels

In order to make transactions suffieiently isolated, we must select an 
appropriate Isolation Level. Each isolation level trades performance for
 further isolation in varying amounts.

Errors which can happen due to poor isolation:
1. Dirty Reads - Reading committed changes from another transaction
<<<<<<< HEAD
2. Non-Repeatable reads - reading of data from a row, then when read again the row has changed due to an ongoing transaction committed.
3. Phantom Reads - The reading of data reutrning a result set then the rereading of the same query, which returns different rows of data.
Phamton because rows disappear then reappear.
=======
2. Non-Repeatable reads - reading of data from a row, then when read 
   again the row has changed due to an ongoing transaction committed.
3. Phantom RReads - The reading of data reutrning a result set then 
   the rereading of the same query, which returns different rows of data.
   Phamton because rows disappear then reappear.
>>>>>>> 1a8014128f6026f2b7d95ead61f1f9880996c75d

Isolation Levels and what they prevent:
1. READ UNCOMMITTED - Prevents nothing, not available in postgresQL
2.READ COMMITTED - Prevents dirty reads. 
		 - Vulnerable to nonrepeatable and phantom reads.
3 Repeatable read - prevents dirty reads and nonrepeatabe reads. 
		  - Vulnerable to phantom reads.
4. Serializable - Prevents all 3 problems. However, may cause a 
		  serialization eror, in postgresql, that should be
		 handeled by  java server

 BEGIN;
 SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
     INSERT INTO users (first_name, last_name, phone,email,city_id) VALUES
	('Maddy','Moore', '1231231234', 'amadf@match',4);
 COMMIT;

=========================================================================
			* Procedural Langage
=========================================================================
==>PROCEDURAL LANGUAGE:
-- In oracle functions are broken into two categories:
	-  FUNCTION & STORED PROCEDURE.
	- In postgresql, there is no syntactical difference between them
	 (Postgre does not made this distinction)
- PstgreSQL actually supports many languages for writing functions,
  including Java.
- Functions must return a value, but returns are optional in procedures

 CREATE OR REPLACE FUNCTION my_sum(a INTEGER, b INTEGER)
 RETURNS INTEGER AS $$ 
   --Delimiter here ^^ signifies beginning and (later) end of fcn
 	BEGIN
		RETURN a + b;
	END;
 $$ LANGUAGE plpgsql;
 --plpgsql stands for procedural language postgresql

 SELECT my_sum(1,2);

 SELECT my_sum(requester,reciever) FROM friends;

-------------------------------------------Function to create a new user:
 CREATE OR REPLACE FUNCTION insert_new_user(
	first_name VARCHAR, 
	last_name VARCHAR, 
	phone VARCHAR, 
	email VARCHAR, 
	city_id INTEGER)
	RETURNS VOID AS $$
		BEGIN
			INSERT INTO users (first_name, last_name, phone,email,city_id) VALUES 
			(first_name, last_name, phone,email,city_id);
		END;
$$ SECURITY DEFINER LANGUAGE plpgsql;
--Security definer function runs with permissions of runction definer, not caller.
-- Good way to let people have access to DB without giving them anything else.
 SELECT insert_new_user('o''riely','Okinawa','2345678909','oriley@oop.org');

==================
CURSORS:
-- Allows to pass a cursor and id value in, should return a cursor which 
   holds the reult set from the query finding a user by id.
-- Cursor - virtual result set that can be returned from function. 
=======
CREATE OR REPLACE FUNCTION get_user(curs refcursor, u_id INTEGER)
	RETURNS refcursor as $$
		BEGIN
  		    OPEN curs FOR SELECT * FROM users WHERE users.id = u_id;	
			RETURN curs;
		END;
$$ LANGUAGE plpsql;

-- NOTE Cursors only exist within a transaction.

 BEGIN;
  SELECT get_user('user',1);
  FETCH ALL IN "user";
 COMMIT;

==============

--RETURN QUERY
Function to pass in id# and get back a list of friends:

CREATE OR REPLACE FUNCTION get_friends(user_id INTEGER)
	RETURNS TABLE (
		id INTEGER,
		first_name VARCHAR,
		last_name VARCHAR,
		phone VARCHAR,
		email VARCHAR,
		city_id INTEGER) AS $$
	BEGIN
	RETURN QUERY SELECT users.id,users.first_name,users.last_name, users.phone, users.email, users.city_id FROM (
		SELECT reciever AS friend_id FROM friends WHERE requester = user_id
		UNION 
		SELECT requester AS friend_id FROM friends WHERE reciever = 3
	) AS origin LEFT JOIN users ON origin.friend_id = users.id;
	END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

SELECT * FROM get_friends(4);

====================
TRIGGERS:

Consider :
ALTER TABLE posts ADD COLUMN post_date TIMESTAMP;
ALTER TABLE posts ADD COLUMN edit_date TIMESTAMP;
UPDATE posts SET post_date = CURRENT_TIMESTAMP;
ALTER TABLE posts ALTER COLUMN post_date SET NOT NULL;

 
SELECT * FROM posts;

-- FIRST: Should we expect a developer to always reasonable set the time stamp to the appropriate post date timestamp?
>Should we expect that the developers never accidentally changes the timestamp?
>Should we expect that any time the posts table is updated, the developer remembers to update  the edited tiem stamp?
>Important question, but answer is NO.
> Should be forget about the original post content? We probably want some revision history that will track past content values.
-- Triggers can be used to insure that the rules are followed.

CREATE TABLE IF NOT EXISTS post_revision_histoy (
	id SERIAL PRIMARY KEY,
	post_id INTEGER REFERENCES posts(id) NOT NULL,
	revision_timestamp TIMESTAMP NOT NULL,
	revision_content VARCHAR(500) NOT NULL
);

-- TRIGGER :
CREATE OR REPLACE FUNCTION post_revision_trigger_func()
RETURNS trigger AS $$
	BEGIN
------------------------------------------------------------------TG_OP -> trigger operation (such as insert, updates, ect)
		IF(TG_OP = 'UPDATE') THEN
			INSERT INTO post_revision_history (post_id,revision_timestamp,revision_content)
									--OLD represents OLD data from UPDATED rows
				VALUES(OLD, id, COALESCE(OLD.edit_date,OLD.post_date), OLD.content);
									-- Coalesce gives first non-null value
			NEW.edit_date = CURRENT_TIMESTAMP;
		END IF;
		IF(TG_OP = 'INSERT') THEN
			NEW.post_date = CURRENT_TIMESTAMP;
			NEW.edit_date = null;
		END IF;

		RETURN NEW;
	END;
$$ SECURITY DEFINER LANGUAGE plpgsql;


CREATE TRIGGER post_revision_trigger
-- Triggers can happen BEFORE, AFTER, or INSTEAD OF----------------------------
	BEFORE INSERT OR UPDATE ON POSTS
	FOR EACH ROW
	EXECUTE PROCEDURE post_revision_trigger_func();

SELECT * FROM posts WHERE id=1
SELECT * FROM post_revision_history;





ALTER TABLE posts 
ADD COLUMN post_date TIMESTAMP;

ALTER TABLE posts ADD COLUMN edit_date TIMESTAMP;

UPDATE posts SET post_date = CURRENT_TIMESTAMP;

ALTER TABLE posts ALTER COLUMN post_date SET NOT NULL;


SELECT * FROM posts;


-- 1. Should we expect the developer to always reasonably set the timestamp

-- to the appropriate post date timestamp?
-- 
2. Should we expect that the developer never accidentally changes the timestamp?

-- 3. Should we expect that anytime the posts table is updated, the developer

-- 		remembers to update the edited time stamp?

-- Other consideration: Should we forget about the original post content? We probably want some kind

-- of revision history that will track past content values.



CREATE TABLE IF NOT EXISTS post_revision_history (

	id SERIAL PRIMARY KEY,

	post_id INTEGER REFERENCES posts(id) NOT NULL,

	revision_timestamp
 TIMESTAMP NOT NULL,

	revision_content VARCHAR(500) NOT NULL
);




CREATE OR REPLACE FUNCTION post_revision_trigger_func()

RETURNS trigger AS $$

	BEGIN

-- TG_OP -> Trigger Operation (such as: INSERT, UPDATE, etc)

		IF(TG_OP = 'UPDATE') THEN

			INSERT INTO post_revision_history (post_id, revision_timestamp, revision_content)

				--     OLD represents old data from updated rows

				VALUES (OLD.id, COALESCE(OLD.edit_date, OLD.post_date), OLD.content);

			NEW.edit_date = CURRENT_TIMESTAMP;

		END IF;

		IF(TG_OP = 'INSERT') THEN

			NEW.post_date = CURRENT_TIMESTAMP;

			NEW.edit_date = NULL;

		END IF;

		RETURN NEW;

	END;

$$ SECURITY DEFINER LANGUAGE plpgsql;


CREATE TRIGGER post_revision_trigger

	BEFORE INSERT OR UPDATE ON posts

	FOR EACH ROW

	EXECUTE PROCEDURE post_revision_trigger_func();

	
SELECT * FROM posts WHERE author_id = 1;

SELECT * FROM post_revision_history;


INSERT INTO posts (author_id, content, post_date, edit_date) VALUES

	(1, 'It''s raining', to_timestamp(2000120400), CURRENT_TIMESTAMP);

UPDATE posts SET content = 'it''s still raining!' WHERE id = 311;

=========================================================================
			* Conceptual 
=========================================================================

==> Making SQL faster : 
- Normalization, but not overnormalized. 
	- Not broken up into TOO many peices.
- Indexes : 
	- Indexes on only important aspects, such as login identities.
	- Don't over-index, as that adds overhead (and slows down you db)
- Joins only when needed
	- Minimize joins which increase row count substantially
		>> Full outer joins may slow down queries. 
- Aggregations take more time than simply rerieving rows. 

Suggestions : 
 - Reduce table size, siltering it to only what you need.
 - Use the LIMIT clause as possible
	- LIMIT post-aggregation will NOT speed up queries.
 - Aggregate before joining if approproate.
 

==> Restricting Access : 
- The DCL (Data Control Language) allows for specific privileges.
GRANT privlege_name ON object_name TO user_name (WITH GRANT OPTION)

	privlege_name : 
		- ALL, EXECUTE, or SELECT
	object_name :
		- TABLE, VIEW, STORED PROC, SEQUENCE
		- can include which table or view IE:
		GRANT SELECT ON VIEW my_view ...
	user_name : name of the user to grant right
		- PUBLIC (grants to all users)
		- or use specific user
		- ROLES role can also be used instead
	WITH GRANT OPTIONS (optional)
		- allows user to grant OTHER users access rights

==> Modeling
- Database does not have to directly mirror class. 
- Only data that needs to be SAVED goes into the DB
- Only add to the DB values that you can't derive from other columns












