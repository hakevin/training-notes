I. Servlets
	* Request Path
	* Singleton
	* Getting Started - Servlets in Java
	* Servlet Architecture
	* Using Servlets
	* Getting Request Information 
	* Status Codes
	* Cookies 
	* Maven Jackson
	* Servlet Scope
	* Depolyment Descriptor
	* CORS Error in JavaScript
	* Classification of Java Objects
II. Angular
	* NPM - Node Package Manager
	* Typescript
	* Getting Started
		* Main Files
	* Angular 4
	* Angular CLI
	* ngModel
	* Components
	* Routes
	* Services
	* HttpClient


====================================================================
========================== I. Servlets =============================
====================================================================

- A servlet is a component that extends the capabilities of a server
- Servlets run inside applications to handle requests. 

====================================================================
		* Request Path
====================================================================

- The request from the front end to/through the server typically
  follows a particular path.
- The server may hold many application. 
- The application may hold many servlets. In a front Servlet 
design, all requests to that application are parsed/handled/directed
from one controller to separate ones. This controls the flow of 
the requests. 
- The controllers act as individual servlets, even though they 
technically are just called from the front servlet. The controllers
read and write requsts.
- The service class handles the logic and rules of the application.
and asks the Dao for information from the database.
- the Dao gets information from the database. 

Condensed path: 
Front end >> server >> application >> servlet >> controller >> 
service >> dao >> datbase

Request req. = localhost:8080/application3/login

	req.	 ____server_____________
[User] -------->|-.			|
		| |  [application1]	|
		| |  [application2]	|
		| '->[application3]	|
		|_______________________|
   _servlet3____________________________________________________
  | req.|	  						|
  |	V	   .->[loginCtrlr]-->[helloService]-->[helloDao]|
  | [frontServlet]-'  [otherCtrlr]   [otherService]   [otherDao]|
  |_____________________________________________________________|

1. From user to server
2. In server, server determines which app to send the request to be server configuration. (tomcat default is the application name)
3. Server reads web.xml to determine which servlet to send it to.
	-Note: frontServlet is the only servlet in this visual,
	  meaning all application3/* requests go to it, but 
	  there can be multiple servlets in an application.
4. Servlet parses and sends request to the proper controller
5. Controller gets logic(rules of application) from Service
6. Service gets data from Dao.
7. Controller writes response based on service methods
8. Response is sent back to the user

==> FrontController vs Page Controller
  Front controller:
	- Simplifies centralization of requests
	- (web.xml only needs to direct to one place)
	- Higher security due to coordinated implementation
	- Needs logic to handle all requests
	- Complex path
  Page Controller: 
	- web.xml grows with the development of application
	- Objects may react inconsistently; lower security
	- Handles requests directly
	- Simple path - request to result
  
=================================================================
		   * Singleton
=================================================================
Singleton design pattern - tool we use when we have some object and
 class where we only need one instance of it. 

Singleton -> class where only 1 object will ever be necessary.
IE: utilitarian things or singular things. 
	-->Scanner or database connection typically singletons

Good if you need something more object-based.
 Good for database managing objects/external resources
 - Especially multi-threading

class Singleton {
	private static Singleton = new Singleton();
	private Singleton(){
		//Instantiaets object
 	}
	public getSingleton(){
		return singleton;
	}
}
 
==================================================================
		* Getting Started - Servlets in Java
==================================================================
>> signifies the path of links or menu items.

==> Initilize Server
-> Be in Java EE mode:
	Eclipse >> Window >> Show Perspective >> other >> Java EE

-> Show your problems tab (window > show view > other > problems)
-> Link to a server:
	Server tab >> new server
		Server type = tomcat9
-> Once loaded, right click the Server > Start.
	(Note: tomcat just has console text in red.)
-> Test in browser : localhost:8080
	Now you can see local server is up and running.


==> Creating the project
-> New Maven Project
	--> NOT a simple project
->On next page: choose webapp option 
	Group :com.revature
	ID: project name
-> App starts with problem, need to configure this. 
	- Right click the project >> Properties
	- Project Facets (on the side)
-> Check dynamic web modules,
	-> Runtimes tab, Check apche tomcat

==> Set up Folders/Servlet
	Now, we need a file that tells the server where to look in the project for the servlets (classes)

--> Set up folder structure (Java folder not included by default)
	- In project tab >> normal main folder (not the java one)
	- Create a java folder (a folder named java)

--> Create class in java for your first Servlet
package com.revature.servlets;

Class MyClass extends DefaultServlet {

//Override method: (See next chapter for what this method IS)
@Override
 service(httpServletRequest request, HttpServletResponse response)
 throws ServletException, IOException {}

//NOTE : that service throws ServiceException and IOException
}

==> Set up path for server
-> Find web.xml file in folders:
	main >> webapp >> web-inf >> web.xml
-> Go to source tab ( ignore design stuff/GUI )
 ***** If you make ANY mistake in the XML, it wont run at all *****
-> within the <web-app> tag, add your servlet
  <servlet>
 	<servlet-name>hello</servlet-name>
  	<servlet-class>
		com.revature.servlets.HelloWorldServlet
	</servlet-class>
  </servlet>

  <servlet-mapping>
  	<servlet-name>hello</servlet-name>
  	<url-pattern>/hello</url-pattern>
  </servlet-mapping>
 
-> Right click server tab >> Add and Remove.
	- Put the servlet you want in the configured side.
	- This gives the project to Tomcat.

-> Double click server to get overview.
	->Go to modules tab to see mapping for project.

==> Start server (see if it starts)

localhost:8080/ServletExample/hello

--> If you get an error, look in your console in eclipse!

==> Moving forward:
- In the XML file, you can change the URL pattern to:
  	<url-pattern>/hello/*</url-pattern>
and it'll send all requests for /myApplication/hello/textHere
to that servlet


====================================================================
		* Servlet Architecture
====================================================================
--> Internal Servlet Hierarchy:
Starts with interface:	Servlet		//interface, no methods
Implemented by:		GenericServlet	//handles responses/request
Extended by:		HttpServlet	//imp. by oracle (javacorelib)
Extended by:		DefaultServlet	//apache tomcat specific
Extended by:		You

--> Inside the servlet
 Service (in an HttpServlet) is a method used to delegate requests to
 an appropriate handler method based on the HTTP method utilized to
 make the request.
 - All requests first go though the Service() method. Afterwards,
 they are typically sent out to the propper HTTP mehod.

	HTTP Method    Handler Method   Crud Operation   SQL
	GET 	->	 doGet		read		SELECT
	POST	->	 doPost		create		CREATE
	PUT 	->	 doPut		update		UPDATE
	DELETE	-> 	 doDelete	delete		DELETE

- Overriding the service() method can be useful to take control
 where the requests are sent, but typically, you'll want to use:
	super.service(request,response);
 after setting up any initial Headers or code you need to run every
 time the servlet gets a request.
- If you don't override service, you can still handle requests with 
 a doGet override. However, if you override service and don't call
 the super, your doGet won't automatically come up. 
- Service method is overloaded:
public void service(ServletRequest req, ServletResponse res)
protected " service(HttpServletRequest req, HttpServletResponse resp)
	- the public method dispatches the client request to the 
protected one 
	- Both throw v IOException and ServletException

==> Servlet Lifecycle
The lifecycle of a servlet has 3 steps:
1. init - Initializing the servlet - Called once
	- Called typically when the FIRST user requests the URL
	  after the server has been initialized.
	- Can be ser to run /when/ the server initializes.
2. service - handling a request - once per request
	- Every time a request is sent in, this is called.
3. destroy - end of servlet lifecycle(shut down) - called once/never
	- Used to clean up lose ends/close resources.

==> Review : DefaultServlet has these methods for Overriding:
Internal handling:
  service	init		destroy		getServletInfo
HTTP request handling:
  doPut		doGet		doPost		doDelete
	
Method signatures (All for overriding) 
protected void doGet(HttpServletRequest req,
                     HttpServletResponse resp)
              throws ServletException,
                     java.io.IOException

==> Request/Response objects
-  HttpServletRequest -> Interface extends ServletRequest
	- Can access (GET) info about the request
	- Passed to service then doGet/Post/ect 
	- Can be used to get cookies, headers, path info, ect
-  HttpServletResponse -> Mirror image of request
	- Used to write into about data to send back
	- Used to SET properties to return 
====================================================================
		* Using Servlets 
====================================================================
How can I get the URL of a request?
request.getRequestURL()
How can I write a response to the client?
response.getWriter().write(s);
or with jackson:
ObjectMapper mapper = new ObjectMapper
mapper.writeValue(response.getWriter(), Object obj)

-> Return Static file from servlet :
- Create RequestDispatcher object 
	- this receives requests from the client and sends them to 
	any resource by wrapping around a server resource located at
	a particular path.
 RequestDispatcher rd = getServletContext()
	.getNamedDispatcher   ("default");
 HttpServletRequest wrapped = new HttpServletRequestWrapper(request){
	public String getServletPath() {return "";}
 };
rd.forward(wrapped,response);

 NOTE: ^^ Above implements an object with a specific instance method.
	- This can be done in classes or whatever. 
	- It overrides that method for that INSTANCE only.
	- This is useful when instantiating interfaces:
  ////some file:
  public interface TestInterface { public void myMethod(); } 
  /// in main of another file:
  TestInterface test = new TestInterface() {
	public void myMethod() {
		System.out.println("Instantiated Interface!");
	}
  };
  //If it's a funcitonal interface, you can use the lambda function	  TestInterface test = () -> {	
	System.out.println("Instantiated Interface!");
  };
		test.myMethod();

-> Reading Request:
	request.getQueryString();
	request.getParameter("parameter_name");
   - With Jackson:
     static ObjectMapper mapper = new ObjectMapper();
     Object obj = mapper.readValue(request.getReader ),Object.class);

-> Forwarding will send the request to another servlet.
	- The user will have no knowledge of this, it is all internal
 	RequestDispatcher dispatcher = getServletContext()
		.getRequestDispatcher("/otherServlet");
	dispatcher.forward(request,response);

-> Redirecting sends the user a response with a new location
	- The browser then takes request and sends it redirect link
	response.sendRedirect("http://google.com");

-> Status code:
	response.setStatus(404);

-> A cookie is a bit of data stored on a user's computer. 
 The data is in the form of a key/value pair.
 It is created by the server and sent in the response.
 To set a cookie:
	Cookie someCookie = new Cookie("cookie_name","value");
	response.addCookie(someCookie);
-> A session is a stored unit on the server. It can hold objects.
	- Creating & getting a session: 
		HttpSession = request.getSession();
	-request.getSession(false) won't create a session, it will
	 return null if there is no session sent.
	- session.setMaxIntactiveInterval(long seconds) will auto-
	invalidate a session if it isn't used in that time period

-> JSESSIONID is the number associated with the session.
 It is used to retrieve information on the server associated with it.
 Creating a session sends a cookie with the key JSESSIONID to user

====================================================================
		* Getting Request Information
====================================================================
==> Path Variables
	- When using GET, the url path contains path variables
	- PATH variables are paramaters/values after the ? IE
   localhost:8080/Example/search?type=3&name=tom

	- The query above is type=3&name=tom
	- The parameters are "type" and "name"
	- The query parameters are "3" and "tom"
Reading Query Parameters:
	request.getQueryString(); // type=3&name=tom
	request.getParameter("name"); //tom

==> Request Body 
When using the POST method, the Http request may contain a BODY.
the POST body is sent in the HTTP request
without a url-concatenation.

POST:
   - With Jackson:
     static ObjectMapper mapper = new ObjectMapper();
     Object obj = mapper.readValue(request.getReader ),Object.class);

====================================================================
			* Status Codes
====================================================================
	100s info
	200s - Success
		201 - Created
	300s Redirect
	400 - Client0side errors
		404- resources not found
		403- forbidden
		01 unaurhotized.
	500 - server-side error
====================================================================
			* Cookies
====================================================================
Cookie- Packet of data saved locally that is automatically sent 
	with future requests. 
-- In get method : 

	Cookie[] cookies = request.getCookies();
	Cookie cookie = new Cookie("my-cookie","test-value");
	response.addCookie(cookie);
-- Cookies are created with key/value pairs
-- Can set expiration date on cookies 
-- By default, server selects oldest cookie of one name and sending 
   a cookie of the same name wont always work

==> Server Sessions
- Simplify the cookie system, and saves temporary data on the server
- Sessions are tracked by cookies
- Session is intended to identify a user who is sending a request.

Sessions collect key-value pairs which can then be accessed between 
request. This allows us to store information about a user throughout
 the lifetime of the session.

-- How it works : 
	- Java produces a cookie called the JSESSIONID that contains
	 a unique token.
	-This token is then provided on future requests identify 	which value map should be provided for the session.

-- Limitations : 
   1. Session information is stored in memory. This means when the
	 application (server) shuts down, the session and all session
	 data are lost.
   2. Also due to information being stored in memory, this makes our
	 application stateful. 

The application must store data for individual users in memory. In
 consequence, the memory requirements of the application will grow
 wiht the number of users. 
 -The results in an application that WILL NOT scale well... 
	(Can work maybe into the 100,000s, but not 1mil+)

 ** State should be the domain of the database. 
	Should NOT be a backend thing. 

-- Methods to keep application statemess :: 
  1. Most straightforward version is to store the token in the DB
   instead of the server. 
  2. Other way : use JSON jwt; json stores info which gets decrypted


==> Creating session:
request.getSession() 
	with no arguments returns the session or create a new one.
request.getSession(true)
	will always get a session - new or old, same as above
request.getSession(false) 
	will get the session or return null.

==> Applying session obj
 _Initiate____
	HttpSession session = request.getSession();
	session.setAttribute("name","clay");
 _In use______
	HttpSession session = request.getSession();
	String name = (String) session.getAttribute("name");
	System.out.println("Message from " + name);

====================================================================
			* Maven Jackson
====================================================================
Maven Jackson - Dependency which maps requests into objects
-- Jackson will NOT work if you don't have getters, setters, and 
	an empty constructor for you object.
-- Jackson is an automatic parses/ deparser with ObjectMapper.

SENDING a response (deparse object to JSON) : 
  ObjectMapper mapper = new ObjectMapper();		
       if(param == null) {
	   mapper.writeValue(response.getWriter(), candies);
	} else {
	   int id = Integer.parseInt(param);
	   mapper.writeValue(response.getWriter(),  candies.get(id));		}

PARSING response (post body to Object) :
  ObjectMapper mapper = new ObjectMapper();
  Candy candy = mapper.readValue(request.getReader(), Candy.class);
  candies.add(candy);
	
==> Note : bigdecimal "probably" has a way to handle converting integers into a decimal or whatever.

==> Can use JsonIgnore annotation in your class so that a particular
 piece of data wont be written on the JSON that the users can see.
				(use this for user_role_id, password)
 -@JsonIgnore will prevent sending the particular field to the JSON that the user can directly access.

===================================================================
			* Servlet Scope
===================================================================
- Scope is a section of code or location of execution in which data
 is valid and accessible.

- Servlet scopes have to do with how data is accessible within a
  JavaEE application.

  1. Request Scope : Things in the request object are created for
 	each request, and this data disappears after the request is 
	completed. 
	- IE: Form data, request-url, request-body, etc.
  2. Session scope - things in a session will survive between
	 requests but are scoped to individual users through the
	 JSESIONID cookie. This data is not persisted between
	 application runs. (When the server restarts, this goes away)
  3. Servlet Scope - A parameter that is defined and accessible only
	 within a single servlet. Defined in web.xml document.
	 Key/value pairs.
  4. Application Scope - a parameter that is defined and accessible 	from any servlet. Defined in the web.xml document. 
	Key/value pairs.

===================================================================
		* Deployment Descriptor
===================================================================
==> Deployment Descriptor is a configuration file for application 
    that is used by the server and specifies to how it get deployed. 
** web.xml is the depolyment descriptor for Java web applications ** 
--Determines how URLs map to the servlets.
--<web-app> is the root element of the .xml file

XML Page Capabilities: (Basic list)
1. Creating and mapping Servlets
2. Configuring how servlets start up. 
3. Map Error codes and exceptions to error pages.
4. Set application or servlet scoped variables. 
++ More
 

  <display-name>Name Used By Admin Tools</display-name>
<!--    Application-Scope Variables -->
  <context-param>
  	<param-name>animal</param-name>
  	<param-value>dog</param-value>
  	<description>Application scope variable, accessible within any servlet.</description>
  </context-param>


  <servlet>
 	 <servlet-name>hello</servlet-name>
  	<servlet-class> 		com.revature.servlets.HelloWorldServlet
	</servlet-class>
<!-- Servlet-Scope Variables -->
  	<init-param>
  		<param-name>name</param-name>
  		<param-value>Ted</param-value>
  		<description>
			This is a servlet-scoped variable, 
			only visible to the hello servlet.
		</description>
  	</init-param>
  </servlet>
  
  
in SERVLET: 
==> Gets param in servlet scope:
	System.out.println(getInitParameter("name"));
		
==>/gets parameter in application scope : 
		System.out.println(getServletContext().getInitParameter("animal"));

==> Session-Parameter:
	request.getAttribute("key");

-------------------------
Web.xml can be used for error handling.
[..........]
  <error-page>
  	<error-code>404</error-code>
  	<location>/404.html</location>
  </error-page>
  
</web-app>
-------------------------


====================================================================
		* CORS error in JavaScript
====================================================================
- CORS error client-side is actually caused by SERVER-side problem.
- When a browser sends a request via javascript, it has to validate 
 that the request is utilized properly. This is a feature implemented
 by web browsers for safety/ responsible use of JS.]

==> Solution: On the server-side you have to override the service 
	method in the controller to allow the access.

protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	response.addHeader("Access-Control-Allow-Origin","*");
	super.service(request, response);
	}

==> The above should allow the JS to get/post, but it might not 
actually allow credentials to be sent. You may have to be more 
specific about your added Headers, as it does not always like the "*"
and instead insists on specific permission:

response
.addHeader("Access-Control-Allow Origin","http://localhost:4200");
response.addHeader("Access-Control-Allow-Credentials","true");		response.addHeader("Access-Control-Allow-Headers","Content-Type, Accept, X-Requested-With");
response.addHeader("Access-Control-Allow-Methods","GET, POST, DELETE, PUT, OPTIONS, HEAD");

==> NOTE: In javaScript:
	Use JSON.stringify(object) to put your object into a string
	to be sent to the API

====================================================================
		* Classifications of Java Objects
====================================================================

Java Bean - Class that meets certain requirements:
	1. All properties private (use getters/setters)
	2. no-args constructor
	3. must be serializable (usually)

POJO - Plain Ol' Java Object not bound by restrictions other than
	those forced by the Java language
	Should not have to:
	> Extend pre-specified class
	> Implement prespecified intergace
	> Contain prespecified annotations


====================================================================
========================== II. Angular =============================
====================================================================
- Runs on typescript
- Allows custom HTML components
- Compiles all the code into one big document and shows individual
 pieces as requested
====================================================================
		 * NPM - Node Package Manager
====================================================================
NPM - Node package manager 
	- Like a Maven, but Node instead.
	- NPM is a command line tool  used to set up dependencies

- To create a new project, cd into the desired folder, then:
	npm init
		-- This creates package.json
- To install new dependencies, the command:
	npm install PACKAGENAME
  -- To install them globally:
	npm install -g PACKAGENAME
  -- Or to install the package directly onto your package.json
	npm install PACKAGENAME --save
- To compile your code and get it running use:
	npm start

==> Webpack (open-source JS bundler tool)
- Node.js is required for installing Webpack
- Webpack is a JavaScript module bundler which puts JS files together
for use in a browser. 
- It takes dependencies and generates elements representing those 
modules.

====================================================================
			* TypeScript:
====================================================================
TypeScript - A superset of JavaScript
- All current JS files can be typescript if you change the extension.
- Major feature : Static typing.
	=> Types that cannot be changed (more like java)
	=> Enforces strong typing.
	=> Access to newer features via transpiling
- Allows access to newer features that browsers may not all support.
- Must be transpiled before used by browser.
- Compile/transpiles code => Converts it all to es5 
				(or desired format)
- Compiler minifies JS and CSS files into one pack w/ smallest size:
	- turns variables into 1 letter(or as small as possible)
	- removes lines breaks
	- minifed code NOT intended to be human-readable
- Developed and maintained by Microsoft

==> Benefits:
	- Security of static typing w/ access to new features

==> Node.js and Visual Studio both can transcribe TypeScript into JS
==> Decorators 
- A decorator function intercepts the creation of a service, 
allowing it to override or modify the behavior of the service.
- In Angular, decorators are used to modify an instance of a class
 without modifying the original source code.
====================================================================
		 * Getting Started
====================================================================
 1.) Download node.js
	- Node.js gives access to npm commands in cmd
	- npm : Node Package Manager for Node JavaScript platform
 2.) npm install -g @angular/cli
	- cli = angular command line interface
	- gives access to ng (aNGular) commands in cmd
 3.) Create a project:
	- cd into directory for your project
	- ng new project-name
 4.) cd project-name (go into the new folder)
	-> npm start
	- You can see your new project on your browser at 
		localhost:4200

~~~~~~~~~~~~~~~~~~~~~~~ * Main Files ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tslint.json
	- Generated by new angular project
	- used to enforce standards of coding
	==> In VS code, click Extensions icon on the left toolbar
		- download TS Lint to use this
tsconfig
	- has line:
		target: "es5"
	- Means typescript will be transpiled into javascript es5
package.json
	- Generated by npm
	- holds dependencies
	- holds command line stuff in script:
		scripts: {
		"ng":"ng"
			...
		 "start" : "ng serve"
	- cmd "npm start" and "ng serve" do the same thing
src>>app folder
  tsconfig.spec - testing
  styles.css - global styles
  polyfills.ts - converts newer features to old ones
  app.component.html - html page of localhost:4200
	- Template for a component of an HTML page.
	- Gets injected into part of the HTML.
  app.componenets.ts:
	@Component ({ //decorator
		selector: 'app-root' //use <app-root></app-root>
		templateUrl: '..' //location of html doc to inject

===================================================================
			* Angular 4
===================================================================
Angular is a framework of code in HTML and JavaScript.
It utilizes HTML as a template language, and extends HTML attributes
 with directives and binding. 
- Directives shape the DOM by manipulating/adding/removing elements
- Binding synchronizes data between the model and the view
- Dependencies allow for developer to specify the location of a 
component instead of hardcoding each and every service into the 
application. Dependency injection is allows for a component to use
a service without creating it's won copy of it.
- A service is a function/object usd to shate data/behavior accross
different sections of the cod. A service is treated a singleton.

==> Angular vs. AngularJs.
 - AngularJS is the first version of Angular. 
	- Based on MVC (model-view-controller) design
	- Model = logic, view = front-end, controller = input/output
	- MVC ought to be called MCV because the controller is the 
	  intermediary between the model and view.
 	- Was completely re-written for the Angular 2 update.
	- Written in JavaScript
	- Binding requires specific ng directives
 - Angular 2 and 4 are very similar, and are called "Angular"
	- Angular 4 is backwards compatible with angular 2
	- Uses components and directives
	- Mainly written in Typescript
	- Syntax uses () for event binding & [] for property binding
	- Implements dependency injection
	- Faster loading, better performing

List of differences:
		    AngularJS		   Angular
Architecture	- components/directives	- MVC
Language	- Typescript		- JavaScript
Expression	- (event) [property]	- specific ng directives
Mobile Support	- Yes			- No
Routing		@RouteConfig{(..)}	-$route.provider.when()
Target User	- Developers		- Designers
===================================================================
			 * Angular CLI 
===================================================================
- Angular CLI (command line interface)
- Commands begin with ng.
=> Create Angular project:
	ng new project-name 
	-- The build process creates all files necessary for an
	   angular project
	-- Including package.json (as it uses node)
	-- Includes main component HTML/ CSS/ and TS files
	-- Initializes git
=> Install package directly to angular project:
	ng install package-name
=> Start your program (does the same as npm start)
	ng serve
		-- This transpiles the code and puts it all together
		-- Also, it will listen for changes in the code,
		  and automatically update upon saves.
=> Generating Components
	ng g c path/name
=> Generate Service
	ng g s path/name
=> Many component blueprints can be generated:
	Use:
	ng g blueprint path/name
	And replance blueprint with one of the following:
	class, directive, enum, guard, interface,
	module, pipe, service

===================================================================
			 * ngModule
===================================================================
- ngModule is a decorator used typically in the root module that
  houses project imports - imports and directives in the ngModule
  will be shared to all components in the project. 
- The top of the file has a list of imports:
	import { name } from 'location';
  and these imports will be used in the @ngModel module.
- The declaration section is for components. Here, you decare each
  component for the project. 
- The imports section is for modules. 
- Providers house services for logic
- Bootstrap section is for the main component that is to be loaded 
  in main.ts

Vocab:
-> Components control views (HTML) 
	- they communicate with other components/services 
	- Create application funcitonality.
-> Modules consist of 1 or more components, and don't control HTML
	- Modules declare which components can be used by components
	  belonging to other modules, which calsses will be injected
	  by depencency injector, and which components get loaded
	- Modules manager components
-> Directives shape/manipulate the DOM and house logic for such
    --Types of directives:
	1. Attribute directive
		- Change the appearance/behavior of elements
	2. Structural directive
		- Change DOM by adding/removing elements
	3. Components
		- Directives that have a template (HTML)
		- Use a simpler interface to hide defaults
-> Pipes - takes data as input, transforms to desired output.
	- A way to display data as you'd like.
		{{ name | uppercase }} display uppercase name string
	- Built-in Examples:
		-uppercase
		- lowercase
		- date:'fullDate'/ date:'shortDate'
==> BrowserModule
 Place the BroswerModule here as an import to gain access to these
 directives. Internally exports CommonModule and ApplicationModule
 Structural Directives:
-- *ngIf="expression" : removes element if expression is falsy
	- Actually removes element from DOM rather than only hide it
-- *ngFor="iterable" : add/remove elements for each iterable size
 Attribute Directives: 
-- [attribute]="expression" : applies attribute expression is truthy
example:
	<button [disabled]="name == 'tom'"> 
	Button will be disabled when the component variable 'name'
	is not 'tom'
====================================================================
			 * Components 
====================================================================
- Angular works on a system of COMPONENTS. 
	Components Modularize the HTML and CSS.
	- they create reusable HTML with rules (js) for HTML sections
	- components can be nested
- Components are special directives that use simple configuration
  and have their own templates.

- Components have their own state, data, template, and styles.
- General components of components
	.ts file (logic)
	.html file (template)
	.css file (style/view)
- Component selectors are the names used as tags in the HTML.
- Components are especially useful for Single Page Applications
  >> SPA - Single Page Applications - have only 1 HTML page.
	- NO change of state.
	- Elements change using JS only
	- Benefit : Give a browser-site a desktop applicaiton feel
	- Made with components and JS logic to contorl what is shown
	- Angular BINDS components together on a page

==> New component - can be done by hand or generated with:
	ng g c components/name
	- If done by hand, be sure your component is imported and
	 declared in the declarations: section in 
		src>>app>>app.module.ts file
	- new component should be within folder:
		src>>app>components>>name
	  where you have access to the .ts, .html, and .css files

==> Javascript for components: 
- Methods and variables are stored in name.component.ts within the   NameComponent class. IE:
	export class UploadReceiptComponent implements OnInit {
	    myTitle = "MY TITLE!";   //component variable
	    constructor() { }
	    myFunction() { 	     //component method
	    }
	    ngOnInit() {
	    }
	}

==> Binding HTML
Data Binding - to JS variable = Interpolation 
	{{ variable }} injects component variable into template 
Event Binding - to Javascript function
  Set action as an attribute within an HTML element ie:
	<button (click)="myFunction()">Go!</button>
Property binding - to CSS class, style, or attribute
	<span [class.myClass]="booleanFunction()">Words</span>
-- This span will have the class myClass while booleanFunction() 
   returns true
-- Can be used for specific properties as well
	<button [disabled]="overOneHundred()">Click</button>

************* FormsModule Allows the use of ngModel *************
2-way Data Binding allows js to interact with forms.
	<input [(ngModel)]="varName" type="text">
- Binds with onchange event, and only works for input values.


==> Lifecycle of Components
"Angular creates it, renders it, creates and renders it’s children,
checks it when it’s data-bound properties change, and destroys it
before removing it from the DOM."
https://angular.io/guide/lifecycle-hooks
- Sequence of events that happen in an components life on the DOM
  ngOnChanges() -For components with input,called when input changes
  ngOnInit()	- Used to initialize data in componnt
		- Called after input vals are set 
		- Called only once
  ngDoCheck()	- Called during all change detection runs
  ngAfterContentInit()  - Called after first ngDoCheck() only
  ngAfterContentChecked()- Called after every ngDoCheck()
  			- 1st run is after ngAfterContentInit()
  ngAfterViewInit() 	- Run after init of componet/child content
  ngAfterViewChecked()	- Called after all content init & checked
			- 1st call after ngAfterViewInit()
			- Called after every ngAfterContentChecked()
  ngOnDestroy()		- Called to clean up when component removed
			- Use to unsubscribe from services

MAIN HOOKS:
	- ngOnChanges() >> Form changes
	- ngOnInit()	>> Initialize component
	- ngAfterViewInit()  >> All content has been initialized
	- ngOnDestroy()	>> When component leaves DOM


==> Binding variables to a child component:
- In the child component, inport @Input.
	- Within the class, add:
	@Input() passedVar: string;
- In the parent element, when it calls the child, specify:
	<app-child-component [passedVar]=componentVariable>
	</app-child-component>

===================================================================
			* Routes
===================================================================
- Routes are used as different "pages" within an application while
  still keeping it all a single-page applicaiton
- The Angular Router activates all required angular components when
 a user navigates to a certain URL. 
- The user can navigate from one page to another without a page 
reload, while still updating browser history so a user can use the
back and forward buttons.
==> Vocabulary
- router service - global Angular router service
- router configuration - definition of all possible route states
	- located in app-routing.module.ts
- router state - the state of the router
- activated route snapshot - access to the URL, parameters, and data
 for a router state node
- guard - script that fetches data before the requested page is 
	deactivated
- router outlet - location in the DOM where angular Router can place
	active components

Features:
-- Application can have nested router-outlets
-- Routes can have nested routes (children)
-- <router-outlet></router-outlet> specified location of route 
   component

In route config, each route can have the following components:
- path: String path to match URL
- pathMatch - how to match URL: default prefix, or full
- component - class reference component to activate
- retirectTo - stringURL to redirect
- data - static date to assign to route
- resolve - dynamic data to revolve/merge w/ data when resolved
- children - child routes

===================================================================
			* Services
===================================================================
- Services act differently from components.
- A service is generally a singleton that has no visual components
 and is essentially the glue between components.

- Use to have components talk to eachother and track how data moves ==> Services are data containers used to comminicate w/components

===================================================================
			* HttpClient
===================================================================
- HttpClient is an injectable class with methods for HTTP requests
==> Methods (general, most have many overflow methods)
 The options section may contain headers, withCredentials: boolean,
 and other information to send with the request. 
  Options is always an optional parameter
	-- request()
	-- delete()
	-- get()
	-- head() 
	-- jsonp
	-- patch()
	-- post()
	-- put()


~~~~~~~~ How to use:
For GET
1. Create Service and start by importing and injecting HttpClient.
	--In the constructor create a private httpClient: HttpClient
2. In ngOnInit (this can be placed anywhere, but for this example,
   ngOnInit will work)
	const url = 'your api url'
	this.httpClient.get('url')
	   .subscribe( data = > console.log(data));

For POST:
	const url = 'your api url'
	payload = {
		// Request body here
	}
	this.httpClient.post(url,payload);
	   .subscribe( data = > console.log(data));

With credentials: 
(This is required if your api tracks cookies or sessions)
	const url = 'your api url'
	payload = {
		// Request body here
	}
	this.httpClient.post(url,payload,{withCredentials:true});
	   .subscribe( data = > console.log(data));


===================================================================
			* RxJS
===================================================================
- RxJS is Reactive JavaScript.
- Allow application to be built to react to events. 
- RxJS allows for asynchronous action in components
- Main Objects:
	- Observer : Allows you to "push" new data into an observable
		sequence. Observers can only add data. "Write-only"
	- Observable : Used to listen to (subscribe) to changes in 		the observer. "Read-Only"
	- Subject - A combination of Observer and Observable.
		You can push new values and subscribe to it.
		"Read and Write"
	- Operators - allow you perform operations
		Way to manipulate data from Subject (or Observer)

==> Application:
-- Typically, data access pipelines are represented with $varName
- To use, set up a Communication Service that will hold variables 
 that are bound to change, and many different components need them to
 operate.
- Components can't easily talk to eachother, so all of them instead 
 will "subscribe" to a variable in the communication service.
- Also, the communication service itself can't run methods of any of 
 the other components it is connected it. 

-- With RxJS, the communicationService can be given data, and then
 send it off to other subscribing components. Components can then
 take that data and use it as they need.
-- With this system, data:
	- Can be sent to multiple places in the pipeline
	- Updates can effect all components with subscriptions
	- Changes alert component to update themselves
-- Subscription:
   - Can be set up to be recieved at time intervals or at updates 	   - Subscribing invokes the set method upon each update

-- The .next() method on Subjects and Observers will update the data.
	-- Imagine I have this object:
		$newspaper = new Subject<string>();
	-- and a method:
		setCurrentNewspaper(paper: string) {
			this.$newspaper.next(paper);
		}
	-- Components who subscribe to the newspaper get updates and 
	  are delivered the new copy every time the .next() method
	  is invoked within the setCurrentNewsPaper method.
	-- With the new newspaper data, the components can do what
	  they want with it: read it, change it, make a paper hat...
	-- Components won't get it if they don't subscribe!


===================================================================
	Class Example with subscriptions (rxjs)
===================================================================

Class Example:
- Goal : create services that allow us to communicate with other
	 services and a second to commincate with the API.
1. Generate components:
first component, second component, 
service communication, service movies

2. Import communication to first.component.ts:
	import { CommunicationService } from 		'src/app/services/communication.service';

// Dependency injection - ad the service to the constructor:
	constructor(private communicationService: 				CommunicationService) { }
//** It must be private in order to be injected


3. In app.module : 
-add CommunicationService as a provider
-add FormsModule import in order to have 2-way data binding with the forms
	import { FormsModule } from '@angular/forms';

==> communicationService is an object in which we can inject variables now and pass them around the page.
In Communication.service.ts, create a method to get each value:
  submitNewValue(value: string) {
    console.log(value);
  }

and on the component, send the value to that function: 
  submit() {
    if (!this.inputValue) {
    return;
    }
    this.communicationService.submitNewValue(this.inputValue);
  }

======
Reactive JavaScript: (notes -g means global)npm install --save rxjs

	npm install -g rxjs

-- Using --save will install that tool on the application we're using. (npm install --save rxjs) and the dependency will be added to your package.json file
==> Reactive JavaScript rxjs allows a system of subscriptions
========

Comminication serice cann't run methods of any of the components it is connected to. 
But with rxjs (reactive javascript)  the comminication service can get data from one place then send it off somewhere else.
	- can be sent multiple places.
	- So updates can effect all ocmponents what need the updateso long as the components subscripbe to teh updates.
	- components that subscribe to the updates will update themselves when updates come in.

Observable = something that's happening. 
             v--- the actual data being updated
subscribe((data)=>{
	//logic
}

   - subscription can be set up to be recieved at time intervals or at updates ect. 
	- by "Subscribing" to communication service, the method will be invoked every time the data is updated.


Steps:
1. component1 invoked method ON connection service:
	communicationService.addSomeData(myInputValue)
2. communicationService updates value
3. reactive angular runs the update

Observable represents an array of items that haven't been resoled yet.
- In our case, only sending 1 thing at a time. 
 - standard observable is ore like asyne

Subject - Something that can be SEEN. 

....
- Data access pipelines are customarily rep'd by starting with $

Inside of CommunicationService:

$listItem = new Subject<string>();
(Recall Subject was the like pipeline thing. "Subject" object has a convenient .next. method to add things to it. Observable objects don't have that)

import { Subject } from 'rxjs';
...
export class CommunicationService {

  $listItem = new Subject<string>();

  constructor() { }

  submitNewValue(value: string) {
    this.$listItem.next(value);
  }
}
~~~~~/~~~~~/~~


import { Component, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { CommunicationService } from 'src/app/services/communication.service';

...

export class SecondComponent implements OnInit {
  listItemSubscription: Subscription;
  items = new Array<string>();
  constructor(
    private communicationService: CommunicationService) { }
  ngOnInit() {
    this.listItemSubscription = this.communicationService
      .$listItem.subscribe( (value) => {
        this.items.push(value);
      });
  }

}

- have a plan to unsubscribe for when component is destoyred! Otherwise there will be multiple copies of the methods and whatnot and your lists will spit out the subscribed-to values multiple times.

Example API key: d563c8ee  (for amdbapi.com a movies API)
http://www.omdbapi.com/?i=tt3896198&apikey=d563c8ee 

ng g s servies services/movie 


'http://www.omdbapi.com/?t=' + movieName + '&apikey=d563c8ee'

?syntax only available in components. It protects us from errors related to null/undefined ojects
{{movie?.Title}}
